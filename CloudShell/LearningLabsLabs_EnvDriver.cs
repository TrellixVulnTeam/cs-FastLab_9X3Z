//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by TestShell Driver Builder Version 7.0.0.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#define TRACE
using System;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Diagnostics;
using System.Security.Permissions;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Proxies;
using System.Collections.Generic;
using System.ComponentModel;
using Microsoft.Win32;
using QualiSystems.Libraries;
using QualiSystems.Driver;

[assembly: AssemblyVersion("1.1.0.0")]
[assembly: AssemblyFileVersion("1.1.0.0")]
[assembly: AssemblyTitle("V1.0.0.0 - Initial Setup.  Messy.  2016.10.12 - Dan Klingler\r\nv1.0.0.1 - Much more progress.  2016.11.4 - Dan Klingler\r\nv1.0.1.0 - Much more work.  First Beta testing wtih Jacob.  2016.11.29 - Dan Klingler\r\nv1.0.1.1 - More minor iterations.  Stitching with Py code.  2016.12.07 - Dan Klingler\r\nv1.1.0.0 - Major rewrite to handle the user being able to claim Provisioning and Off systems.  Uggh!  2016.12.09 - Dan Klingler\r\n\r\n")]
[assembly: AssemblyProduct("[<AssemblyName>] 7.0.0")]
[assembly: Library(typeof(LearningLabsLabs_EnvDriver), "", IsolationLevel.PerLibrary)]
[assembly: MethodsCategory("Hidden Commands", 0)]
[assembly: MethodsCategory("Commands", 1)]




namespace QualiSystems.Driver
{
	[Description("V1.0.0.0 - Initial Setup.  Messy.  2016.10.12 - Dan Klingler\r\nv1.0.0.1 - Much more progress.  2016.11.4 - Dan Klingler\r\nv1.0.1.0 - Much more work.  First Beta testing wtih Jacob.  2016.11.29 - Dan Klingler\r\nv1.0.1.1 - More minor iterations.  Stitching with Py code.  2016.12.07 - Dan Klingler\r\nv1.1.0.0 - Major rewrite to handle the user being able to claim Provisioning and Off systems.  Uggh!  2016.12.09 - Dan Klingler\r\n\r\n")]
    public class LearningLabsLabs_EnvDriver : ICancelable, IDisposable
    {
        private static readonly Assembly DriverRuntimeAssembly;
        private static readonly string DriverRuntimeTypeName;
        private static readonly string DriverCodeBase;
		private Guid m_DriverIdentifier;
        
		private IFunctionInterpreter m_EntryPointFunctionInterpreter = null;
		private object m_EntryPointFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_SetupFunctionInterpreter = null;
		private object m_SetupFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_TeardownFunctionInterpreter = null;
		private object m_TeardownFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Action_AssociationFunctionInterpreter = null;
		private object m_Action_AssociationFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Action_EnvInfoFunctionInterpreter = null;
		private object m_Action_EnvInfoFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Action_FreeZombiesFunctionInterpreter = null;
		private object m_Action_FreeZombiesFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Action_ManagePoolFunctionInterpreter = null;
		private object m_Action_ManagePoolFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Action_RequestFunctionInterpreter = null;
		private object m_Action_RequestFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Action_ResetStateFunctionInterpreter = null;
		private object m_Action_ResetStateFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Action_TerminateFunctionInterpreter = null;
		private object m_Action_TerminateFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_System_ClaimFunctionInterpreter = null;
		private object m_System_ClaimFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_System_GetAttributeFunctionInterpreter = null;
		private object m_System_GetAttributeFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_System_ProvisionFunctionInterpreter = null;
		private object m_System_ProvisionFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_System_ProvisionOffClaimedFunctionInterpreter = null;
		private object m_System_ProvisionOffClaimedFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_System_SetAttributeFunctionInterpreter = null;
		private object m_System_SetAttributeFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_System_TerminateFunctionInterpreter = null;
		private object m_System_TerminateFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Util_GetReservationIdFunctionInterpreter = null;
		private object m_Util_GetReservationIdFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Util_GetSystemAttributeInformationFunctionInterpreter = null;
		private object m_Util_GetSystemAttributeInformationFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Util_ProvisioningPushFunctionInterpreter = null;
		private object m_Util_ProvisioningPushFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Util_QueryUserHasActiveSystemFunctionInterpreter = null;
		private object m_Util_QueryUserHasActiveSystemFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_Util_ToOutputWindowFunctionInterpreter = null;
		private object m_Util_ToOutputWindowFunctionInterpreterLock = new object();
		private IFunctionInterpreter m_VCenter_SystemOnOffFunctionInterpreter = null;
		private object m_VCenter_SystemOnOffFunctionInterpreterLock = new object();

		
		static LearningLabsLabs_EnvDriver()
		{
			DriverCodeBase = Assembly.GetExecutingAssembly().CodeBase;
			TestShellRuntimeLocator runtimeLocator = new TestShellRuntimeLocator("7.0.0");
            DriverRuntimeAssembly = runtimeLocator.RuntimeAssembly;
            DriverRuntimeTypeName = runtimeLocator.RuntimeTypeName;
		}
		
		private void __Shutdown() 
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			runtimeType.GetMethod("Shutdown").Invoke(null, BindingFlags.Public | BindingFlags.Static, null, new object[0], null);
		}

        public LearningLabsLabs_EnvDriver()
        {
			m_DriverIdentifier = Guid.NewGuid();

			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			bool IsSupportedVersion = (bool)runtimeType.GetMethod("IsSupportedRuntimeVersion").Invoke(null, new object[]{"7.0.0"});
			if (!IsSupportedVersion)
				throw TestShellRuntimeLocator.NoMatchingRuntimeException("7.0.0");

			runtimeType.GetMethod("InitializeRuntime").Invoke(null, new object[]{Assembly.GetExecutingAssembly().CodeBase, "LearningLabsLabs_EnvDriver", m_DriverIdentifier.ToString()});
                      
			m_EntryPointFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\EntryPoint.tsdrv");
			m_SetupFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Commands\\Setup.tsdrv");
			m_TeardownFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Commands\\Teardown.tsdrv");
			m_Action_AssociationFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_Association.tsdrv");
			m_Action_EnvInfoFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_EnvInfo.tsdrv");
			m_Action_FreeZombiesFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_FreeZombies.tsdrv");
			m_Action_ManagePoolFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_ManagePool.tsdrv");
			m_Action_RequestFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_Request.tsdrv");
			m_Action_ResetStateFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_ResetState.tsdrv");
			m_Action_TerminateFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_Terminate.tsdrv");
			m_System_ClaimFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_Claim.tsdrv");
			m_System_GetAttributeFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_GetAttribute.tsdrv");
			m_System_ProvisionFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_Provision.tsdrv");
			m_System_ProvisionOffClaimedFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_ProvisionOffClaimed.tsdrv");
			m_System_SetAttributeFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_SetAttribute.tsdrv");
			m_System_TerminateFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_Terminate.tsdrv");
			m_Util_GetReservationIdFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_GetReservationId.tsdrv");
			m_Util_GetSystemAttributeInformationFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_GetSystemAttributeInformation.tsdrv");
			m_Util_ProvisioningPushFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_ProvisioningPush.tsdrv");
			m_Util_QueryUserHasActiveSystemFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_QueryUserHasActiveSystem.tsdrv");
			m_Util_ToOutputWindowFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_ToOutputWindow.tsdrv");
			m_VCenter_SystemOnOffFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\VCenter_SystemOnOff.tsdrv");

        }
        
        public static int Main(string[] args)
        {
            LearningLabsLabs_EnvDriver driverInstance = new LearningLabsLabs_EnvDriver();
            int retVal = (int)driverInstance.@EntryPoint(args);
            driverInstance.__Shutdown();
            return retVal;
        }
        
		[Hidden]
		public CancellationContext CreateCancellationContext()
		{
			return new CancellationContext();
		}

		[Hidden]
		public bool Cancel(CancellationContext cancellationContext)
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			return (bool)runtimeType.GetMethod("Cancel").Invoke(null, new object[]{cancellationContext.CallId});
		}

		[Hidden]
		public void Dispose()
		{
			Type runtimeType = DriverRuntimeAssembly.GetType(DriverRuntimeTypeName);
			runtimeType.GetMethod("DisposeDriverInstance").Invoke(null, new object[]{m_DriverIdentifier.ToString()});
		}

        private IFunctionInterpreter CreateFunctionInterpreter(string functionVirtualPath)
        {
            return new DucktypingProxy<IFunctionInterpreter>(DriverRuntimeAssembly.CreateInstance(
                    DriverRuntimeTypeName, false, BindingFlags.Default, null, new object[] { m_DriverIdentifier.ToString(), functionVirtualPath }, null, null)).TransparentProxy;
        }

		[Description("Main entry point for an executable")]
		[Cancelable]
		public int @EntryPoint([Alias("argsparam")]  string[] @argsparam)
		{
			lock(m_EntryPointFunctionInterpreterLock)
			{
				if(m_EntryPointFunctionInterpreter == null)
					m_EntryPointFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\EntryPoint.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["argsparam"] = @argsparam;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["Returnparam"] = typeof(int);
			Dictionary<string, object> outputNamesValues = m_EntryPointFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			return (int)outputNamesValues["Returnparam"];
		}

		[Description("Prepares the lab for use, adds user to VPN")]
		[MethodOrder(Order = 0, CategoryName = "Commands")]
		[Folder("Commands")]
		[Cancelable]
		public void @Setup([Alias("out")] out string @out, [Description("A predefined matrix with the following columns: attribute, mandatory / optional (empty is mandatory), value - this column will be automatically populated when executing the command.")][Alias("reservation")][ParameterDefaultValue("{['Username','','';'Password','','';'Domain','','';'ReservationId','','']}")]  string[,] @reservation)
		{
			lock(m_SetupFunctionInterpreterLock)
			{
				if(m_SetupFunctionInterpreter == null)
					m_SetupFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Commands\\Setup.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["reservation"] = @reservation;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["out"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_SetupFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@out =  (string)outputNamesValues["out"];
		}

		[Description("Decomissions VMs, removes user from VPN")]
		[MethodOrder(Order = 0, CategoryName = "Hidden Commands")]
		[Folder("Commands")]
		[Cancelable]
		public void @Teardown([Alias("out")] out string @out, [Description("A predefined matrix with the following columns: attribute, mandatory / optional (empty is mandatory), value - this column will be automatically populated when executing the command.")][Alias("reservation")][ParameterDefaultValue("{['Username','','';'Password','','';'Domain','','';'ReservationId','','']}")]  string[,] @reservation)
		{
			lock(m_TeardownFunctionInterpreterLock)
			{
				if(m_TeardownFunctionInterpreter == null)
					m_TeardownFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Commands\\Teardown.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["reservation"] = @reservation;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["out"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_TeardownFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@out =  (string)outputNamesValues["out"];
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Action_Association([Alias("UserID")]  string @UserID)
		{
			lock(m_Action_AssociationFunctionInterpreterLock)
			{
				if(m_Action_AssociationFunctionInterpreter == null)
					m_Action_AssociationFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_Association.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["UserID"] = @UserID;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Action_AssociationFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Action_EnvInfo([Alias("UserID")]  string @UserID)
		{
			lock(m_Action_EnvInfoFunctionInterpreterLock)
			{
				if(m_Action_EnvInfoFunctionInterpreter == null)
					m_Action_EnvInfoFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_EnvInfo.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["UserID"] = @UserID;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Action_EnvInfoFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Action_FreeZombies()
		{
			lock(m_Action_FreeZombiesFunctionInterpreterLock)
			{
				if(m_Action_FreeZombiesFunctionInterpreter == null)
					m_Action_FreeZombiesFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_FreeZombies.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Action_FreeZombiesFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Action_ManagePool()
		{
			lock(m_Action_ManagePoolFunctionInterpreterLock)
			{
				if(m_Action_ManagePoolFunctionInterpreter == null)
					m_Action_ManagePoolFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_ManagePool.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Action_ManagePoolFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Action_Request([Alias("UserID")]  string @UserID, [Alias("TTL_Mins")]  double @TTL_Mins)
		{
			lock(m_Action_RequestFunctionInterpreterLock)
			{
				if(m_Action_RequestFunctionInterpreter == null)
					m_Action_RequestFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_Request.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["UserID"] = @UserID;
			inputNamesValues["TTL_Mins"] = @TTL_Mins;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Action_RequestFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Action_ResetState()
		{
			lock(m_Action_ResetStateFunctionInterpreterLock)
			{
				if(m_Action_ResetStateFunctionInterpreter == null)
					m_Action_ResetStateFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_ResetState.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Action_ResetStateFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Action_Terminate([Alias("UserID")]  string @UserID)
		{
			lock(m_Action_TerminateFunctionInterpreterLock)
			{
				if(m_Action_TerminateFunctionInterpreter == null)
					m_Action_TerminateFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Action_Terminate.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["UserID"] = @UserID;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Action_TerminateFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @System_Claim([Alias("UserID")]  string @UserID, [Alias("RAM_READY")]  string[,] @RAM_READY, [Alias("RAM_PROV_Unclaimed")]  string[,] @RAM_PROV_Unclaimed, [Alias("RAM_OFF_Unclaimed")]  string[,] @RAM_OFF_Unclaimed, [Alias("NumInState_READY")]  double @NumInState_READY, [Alias("NumInState_OFF_Unclaimed")]  double @NumInState_OFF_Unclaimed, [Alias("NumInState_PROV_Unclaimed")]  double @NumInState_PROV_Unclaimed, [Alias("FLAG_CLAIM_SUCCESS")] out double @FLAG_CLAIM_SUCCESS, [Alias("ClaimedSystemName")] out string @ClaimedSystemName, [Alias("FLAG_LOST_RACE")] out double @FLAG_LOST_RACE)
		{
			lock(m_System_ClaimFunctionInterpreterLock)
			{
				if(m_System_ClaimFunctionInterpreter == null)
					m_System_ClaimFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_Claim.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["UserID"] = @UserID;
			inputNamesValues["RAM_READY"] = @RAM_READY;
			inputNamesValues["RAM_PROV_Unclaimed"] = @RAM_PROV_Unclaimed;
			inputNamesValues["RAM_OFF_Unclaimed"] = @RAM_OFF_Unclaimed;
			inputNamesValues["NumInState_READY"] = @NumInState_READY;
			inputNamesValues["NumInState_OFF_Unclaimed"] = @NumInState_OFF_Unclaimed;
			inputNamesValues["NumInState_PROV_Unclaimed"] = @NumInState_PROV_Unclaimed;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["FLAG_CLAIM_SUCCESS"] = typeof(double);
			outputNamesTypes["ClaimedSystemName"] = typeof(string);
			outputNamesTypes["FLAG_LOST_RACE"] = typeof(double);
			Dictionary<string, object> outputNamesValues = m_System_ClaimFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@FLAG_CLAIM_SUCCESS =  (double)outputNamesValues["FLAG_CLAIM_SUCCESS"];
			@ClaimedSystemName =  (string)outputNamesValues["ClaimedSystemName"];
			@FLAG_LOST_RACE =  (double)outputNamesValues["FLAG_LOST_RACE"];
		}

		[Folder("Functions")]
		[Cancelable]
		public void @System_GetAttribute([Alias("SystemName")]  string @SystemName, [Alias("AttributeName")]  string @AttributeName, [Alias("AttributeValue")] out string @AttributeValue)
		{
			lock(m_System_GetAttributeFunctionInterpreterLock)
			{
				if(m_System_GetAttributeFunctionInterpreter == null)
					m_System_GetAttributeFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_GetAttribute.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["SystemName"] = @SystemName;
			inputNamesValues["AttributeName"] = @AttributeName;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["AttributeValue"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_System_GetAttributeFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@AttributeValue =  (string)outputNamesValues["AttributeValue"];
		}

		[Folder("Functions")]
		[Cancelable]
		public void @System_Provision([Alias("SystemName")]  string @SystemName, [Alias("BootTimeSecs")]  double @BootTimeSecs, [Alias("UserID")]  string @UserID)
		{
			lock(m_System_ProvisionFunctionInterpreterLock)
			{
				if(m_System_ProvisionFunctionInterpreter == null)
					m_System_ProvisionFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_Provision.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["SystemName"] = @SystemName;
			inputNamesValues["BootTimeSecs"] = @BootTimeSecs;
			inputNamesValues["UserID"] = @UserID;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_System_ProvisionFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @System_ProvisionOffClaimed()
		{
			lock(m_System_ProvisionOffClaimedFunctionInterpreterLock)
			{
				if(m_System_ProvisionOffClaimedFunctionInterpreter == null)
					m_System_ProvisionOffClaimedFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_ProvisionOffClaimed.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_System_ProvisionOffClaimedFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @System_SetAttribute([Alias("SystemName")]  string @SystemName, [Alias("AttributeName")]  string @AttributeName, [Alias("NewAttributeValue")]  string @NewAttributeValue)
		{
			lock(m_System_SetAttributeFunctionInterpreterLock)
			{
				if(m_System_SetAttributeFunctionInterpreter == null)
					m_System_SetAttributeFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_SetAttribute.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["SystemName"] = @SystemName;
			inputNamesValues["AttributeName"] = @AttributeName;
			inputNamesValues["NewAttributeValue"] = @NewAttributeValue;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_System_SetAttributeFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @System_Terminate([Alias("SystemName")]  string @SystemName, [Alias("VMName")]  string @VMName)
		{
			lock(m_System_TerminateFunctionInterpreterLock)
			{
				if(m_System_TerminateFunctionInterpreter == null)
					m_System_TerminateFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\System_Terminate.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["SystemName"] = @SystemName;
			inputNamesValues["VMName"] = @VMName;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_System_TerminateFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Util_GetReservationId([Alias("LabName")]  string @LabName, [Alias("ReservationID")] out string @ReservationID)
		{
			lock(m_Util_GetReservationIdFunctionInterpreterLock)
			{
				if(m_Util_GetReservationIdFunctionInterpreter == null)
					m_Util_GetReservationIdFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_GetReservationId.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["LabName"] = @LabName;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["ReservationId"] = typeof(string);
			Dictionary<string, object> outputNamesValues = m_Util_GetReservationIdFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@ReservationID =  (string)outputNamesValues["ReservationId"];
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Util_GetSystemAttributeInformation([Alias("RAM_FULL")] out string[,] @RAM_FULL, [Alias("RAM_ERROR")] out string[,] @RAM_ERROR, [Alias("RAM_INUSE")] out string[,] @RAM_INUSE, [Alias("RAM_MAX")] out string[,] @RAM_MAX, [Alias("RAM_READY")] out string[,] @RAM_READY, [Alias("RAM_OFF")] out string[,] @RAM_OFF, [Alias("RAM_OFF_Claimed")] out string[,] @RAM_OFF_Claimed, [Alias("RAM_OFF_Unclaimed")] out string[,] @RAM_OFF_Unclaimed, [Alias("RAM_PROV")] out string[,] @RAM_PROV, [Alias("RAM_PROV_Claimed")] out string[,] @RAM_PROV_Claimed, [Alias("RAM_PROV_Unclaimed")] out string[,] @RAM_PROV_Unclaimed, [Alias("NumInState_ERROR")] out double @NumInState_ERROR, [Alias("NumInState_FULL")] out double @NumInState_FULL, [Alias("NumInState_INUSE")] out double @NumInState_INUSE, [Alias("NumInState_MAX")] out double @NumInState_MAX, [Alias("NumInState_READY")] out double @NumInState_READY, [Alias("NumInState_OFF")] out double @NumInState_OFF, [Alias("NumInState_OFF_Claimed")] out double @NumInState_OFF_Claimed, [Alias("NumInState_OFF_Unclaimed")] out double @NumInState_OFF_Unclaimed, [Alias("NumInState_PROV")] out double @NumInState_PROV, [Alias("NumInState_PROV_Claimed")] out double @NumInState_PROV_Claimed, [Alias("NumInState_PROV_Unclaimed")] out double @NumInState_PROV_Unclaimed, [Alias("FastLab_BootTimeSecs")] out double @FastLab_BootTimeSecs, [Alias("FastLab_LabDefaultTTLMins")] out double @FastLab_LabDefaultTTLMins, [Alias("FastLab_ReadyPoolSize")] out double @FastLab_ReadyPoolSize)
		{
			lock(m_Util_GetSystemAttributeInformationFunctionInterpreterLock)
			{
				if(m_Util_GetSystemAttributeInformationFunctionInterpreter == null)
					m_Util_GetSystemAttributeInformationFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_GetSystemAttributeInformation.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["RAM_FULL"] = typeof(string[,]);
			outputNamesTypes["RAM_ERROR"] = typeof(string[,]);
			outputNamesTypes["RAM_INUSE"] = typeof(string[,]);
			outputNamesTypes["RAM_MAX"] = typeof(string[,]);
			outputNamesTypes["RAM_READY"] = typeof(string[,]);
			outputNamesTypes["RAM_OFF"] = typeof(string[,]);
			outputNamesTypes["RAM_OFF_Claimed"] = typeof(string[,]);
			outputNamesTypes["RAM_OFF_Unclaimed"] = typeof(string[,]);
			outputNamesTypes["RAM_PROV"] = typeof(string[,]);
			outputNamesTypes["RAM_PROV_Claimed"] = typeof(string[,]);
			outputNamesTypes["RAM_PROV_Unclaimed"] = typeof(string[,]);
			outputNamesTypes["NumInState_ERROR"] = typeof(double);
			outputNamesTypes["NumInState_FULL"] = typeof(double);
			outputNamesTypes["NumInState_INUSE"] = typeof(double);
			outputNamesTypes["NumInState_MAX"] = typeof(double);
			outputNamesTypes["NumInState_READY"] = typeof(double);
			outputNamesTypes["NumInState_OFF"] = typeof(double);
			outputNamesTypes["NumInState_OFF_Claimed"] = typeof(double);
			outputNamesTypes["NumInState_OFF_Unclaimed"] = typeof(double);
			outputNamesTypes["NumInState_PROV"] = typeof(double);
			outputNamesTypes["NumInState_PROV_Claimed"] = typeof(double);
			outputNamesTypes["NumInState_PROV_Unclaimed"] = typeof(double);
			outputNamesTypes["FastLab_BootTimeSecs"] = typeof(double);
			outputNamesTypes["FastLab_LabDefaultTTLMins"] = typeof(double);
			outputNamesTypes["FastLab_ReadyPoolSize"] = typeof(double);
			Dictionary<string, object> outputNamesValues = m_Util_GetSystemAttributeInformationFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@RAM_FULL =  (string[,])outputNamesValues["RAM_FULL"];
			@RAM_ERROR =  (string[,])outputNamesValues["RAM_ERROR"];
			@RAM_INUSE =  (string[,])outputNamesValues["RAM_INUSE"];
			@RAM_MAX =  (string[,])outputNamesValues["RAM_MAX"];
			@RAM_READY =  (string[,])outputNamesValues["RAM_READY"];
			@RAM_OFF =  (string[,])outputNamesValues["RAM_OFF"];
			@RAM_OFF_Claimed =  (string[,])outputNamesValues["RAM_OFF_Claimed"];
			@RAM_OFF_Unclaimed =  (string[,])outputNamesValues["RAM_OFF_Unclaimed"];
			@RAM_PROV =  (string[,])outputNamesValues["RAM_PROV"];
			@RAM_PROV_Claimed =  (string[,])outputNamesValues["RAM_PROV_Claimed"];
			@RAM_PROV_Unclaimed =  (string[,])outputNamesValues["RAM_PROV_Unclaimed"];
			@NumInState_ERROR =  (double)outputNamesValues["NumInState_ERROR"];
			@NumInState_FULL =  (double)outputNamesValues["NumInState_FULL"];
			@NumInState_INUSE =  (double)outputNamesValues["NumInState_INUSE"];
			@NumInState_MAX =  (double)outputNamesValues["NumInState_MAX"];
			@NumInState_READY =  (double)outputNamesValues["NumInState_READY"];
			@NumInState_OFF =  (double)outputNamesValues["NumInState_OFF"];
			@NumInState_OFF_Claimed =  (double)outputNamesValues["NumInState_OFF_Claimed"];
			@NumInState_OFF_Unclaimed =  (double)outputNamesValues["NumInState_OFF_Unclaimed"];
			@NumInState_PROV =  (double)outputNamesValues["NumInState_PROV"];
			@NumInState_PROV_Claimed =  (double)outputNamesValues["NumInState_PROV_Claimed"];
			@NumInState_PROV_Unclaimed =  (double)outputNamesValues["NumInState_PROV_Unclaimed"];
			@FastLab_BootTimeSecs =  (double)outputNamesValues["FastLab_BootTimeSecs"];
			@FastLab_LabDefaultTTLMins =  (double)outputNamesValues["FastLab_LabDefaultTTLMins"];
			@FastLab_ReadyPoolSize =  (double)outputNamesValues["FastLab_ReadyPoolSize"];
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Util_ProvisioningPush([Alias("NumInState_PROV")]  double @NumInState_PROV, [Alias("RAM_PROV")]  string[,] @RAM_PROV, [Alias("MadeUpdates")] out double @MadeUpdates)
		{
			lock(m_Util_ProvisioningPushFunctionInterpreterLock)
			{
				if(m_Util_ProvisioningPushFunctionInterpreter == null)
					m_Util_ProvisioningPushFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_ProvisioningPush.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["NumInState_PROV"] = @NumInState_PROV;
			inputNamesValues["RAM_PROV"] = @RAM_PROV;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["MadeUpdates"] = typeof(double);
			Dictionary<string, object> outputNamesValues = m_Util_ProvisioningPushFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@MadeUpdates =  (double)outputNamesValues["MadeUpdates"];
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Util_QueryUserHasActiveSystem([Alias("RAM_FULL")]  string[,] @RAM_FULL, [Alias("UserID")]  string @UserID, [Alias("Result_Matrix")] out string[,] @Result_Matrix, [Alias("Result_NumUserEntries")] out double @Result_NumUserEntries)
		{
			lock(m_Util_QueryUserHasActiveSystemFunctionInterpreterLock)
			{
				if(m_Util_QueryUserHasActiveSystemFunctionInterpreter == null)
					m_Util_QueryUserHasActiveSystemFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_QueryUserHasActiveSystem.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["RAM_FULL"] = @RAM_FULL;
			inputNamesValues["UserID"] = @UserID;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			outputNamesTypes["Result_Matrix"] = typeof(string[,]);
			outputNamesTypes["Result_NumUserEntries"] = typeof(double);
			Dictionary<string, object> outputNamesValues = m_Util_QueryUserHasActiveSystemFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
			@Result_Matrix =  (string[,])outputNamesValues["Result_Matrix"];
			@Result_NumUserEntries =  (double)outputNamesValues["Result_NumUserEntries"];
		}

		[Folder("Functions")]
		[Cancelable]
		public void @Util_ToOutputWindow([Alias("OutMsg")]  string @OutMsg)
		{
			lock(m_Util_ToOutputWindowFunctionInterpreterLock)
			{
				if(m_Util_ToOutputWindowFunctionInterpreter == null)
					m_Util_ToOutputWindowFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\Util_ToOutputWindow.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["OutMsg"] = @OutMsg;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_Util_ToOutputWindowFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}

		[Folder("Functions")]
		[Cancelable]
		public void @VCenter_SystemOnOff([Alias("VMName")]  string @VMName, [Alias("CommandString")]  string @CommandString)
		{
			lock(m_VCenter_SystemOnOffFunctionInterpreterLock)
			{
				if(m_VCenter_SystemOnOffFunctionInterpreter == null)
					m_VCenter_SystemOnOffFunctionInterpreter = CreateFunctionInterpreter("LearningLabsLabs_EnvDriver\\Functions\\VCenter_SystemOnOff.tsdrv");
			}
			Guid callId = Guid.Empty;
			if(CancellationContext.Current != null)
				callId = CancellationContext.Current.CallId;
			Dictionary<string, object> inputNamesValues = new Dictionary<string, object>();
			inputNamesValues["VMName"] = @VMName;
			inputNamesValues["ActionString"] = @CommandString;
			Dictionary<string, Type> outputNamesTypes = new Dictionary<string, Type>();
			Dictionary<string, object> outputNamesValues = m_VCenter_SystemOnOffFunctionInterpreter.Run(callId, inputNamesValues, outputNamesTypes);
		}


   
        #region DucktypingProxy
        
		[DebuggerStepThrough]
		internal class DucktypingProxy<TTarget> : RealProxy where TTarget : class
		{
			private object m_Target;

			public DucktypingProxy(object target) : base(typeof(TTarget))
			{
				m_Target = target;
			}

			[SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.Infrastructure)]
			public override IMessage Invoke(IMessage msg)
			{
				IMethodCallMessage methodMessage = new MethodCallMessageWrapper((IMethodCallMessage)msg);
				MethodBase method = methodMessage.MethodBase;
				object returnValue = null;
				ReturnMessage returnMessage = null;

				try
				{
					MethodBase targetMethod = GetTargetMethodFromInterfaceMethod(method);
					if (targetMethod == null)
						throw new NotImplementedException(string.Format("Method {0} was not implemented by the target", method.Name));
					returnValue = targetMethod.Invoke(m_Target, methodMessage.Args);
					returnMessage = new ReturnMessage(returnValue, methodMessage.Args, methodMessage.ArgCount, methodMessage.LogicalCallContext, methodMessage);
				}
				catch (Exception ex)
				{
					if ((ex is RemotingException || ex is TargetInvocationException)
						&& ex.InnerException != null)
						ex = ex.InnerException;

					returnMessage = new ReturnMessage(ex, methodMessage);
				}

				return returnMessage;
			}

			private MethodBase GetTargetMethodFromInterfaceMethod(MethodBase interfaceMethod)
			{
				ParameterInfo[] interfaceMethodParameters = interfaceMethod.GetParameters();
				Type[] parameterTypes = new Type[interfaceMethodParameters.Length];
				for (int i = 0; i < parameterTypes.Length; i++)
				{
					parameterTypes[i] = interfaceMethodParameters[i].ParameterType;
				}

				MethodInfo targetMethod;
				if (interfaceMethod.IsGenericMethod)
					targetMethod = m_Target.GetType().GetMethod(interfaceMethod.Name, parameterTypes).MakeGenericMethod(interfaceMethod.GetGenericArguments());
				else
					targetMethod = m_Target.GetType().GetMethod(interfaceMethod.Name, parameterTypes);

				return targetMethod;
			}

			public TTarget TransparentProxy
			{
				get
				{
					return base.GetTransparentProxy() as TTarget;
				}
			}
		}
		
		#endregion DucktypingProxy
		
		#region TestShellRuntimeLocator

        internal class TestShellRuntimeLocator
        {
            private const string RuntimeRepositoryPath = @"Software\QualiSystems\TestShellRuntime";

            public Assembly RuntimeAssembly { get; private set; }
            public string RuntimeTypeName { get; private set; }

            public TestShellRuntimeLocator(string targetRuntimeVersion)
            {
				Trace.WriteLine("Quali Runtime: Target runtime version is " +targetRuntimeVersion+ ", searching for matching installed versions...");
                var runtimeInfos = ReadInstalledTestShellRuntimeInfos(targetRuntimeVersion);
                TestShellRuntimeInfo selectedRuntimeInfo = SelectRuntimeVersionInfo(runtimeInfos, targetRuntimeVersion);
                RuntimeTypeName = selectedRuntimeInfo.RuntimeTypeName;
                string runtimeAssemblyPath = Path.Combine(selectedRuntimeInfo.Path, selectedRuntimeInfo.RuntimeAssemblyName);
                if (!System.IO.File.Exists(runtimeAssemblyPath))
                    throw RuntimeAssemblyNotFound(runtimeAssemblyPath);
                Trace.WriteLine("Quali Runtime: Loading runtime version " +selectedRuntimeInfo.Version+ " from " + runtimeAssemblyPath);
                RuntimeAssembly = Assembly.LoadFrom(runtimeAssemblyPath);
            }

            private static TestShellRuntimeInfo SelectRuntimeVersionInfo(IEnumerable<TestShellRuntimeInfo> runtimeInfos, string targetRuntimeVersion)
            {
                TestShellRuntimeInfo runtimeInfo = GetCurrentlyLoadedRuntimeInfo(runtimeInfos);
                if (runtimeInfo != null)
                {
                    if(!IsGreaterOrEqualVersion(runtimeInfo.Version, targetRuntimeVersion))
                        throw IncompatibleRuntimeLoaded(targetRuntimeVersion, runtimeInfo.Version);
                }
                else
                {
					var matchingRuntimeInfos = GetMatchingRuntimeInfos(runtimeInfos, targetRuntimeVersion);
					if (!matchingRuntimeInfos.Any())
						throw NoMatchingRuntimeException(targetRuntimeVersion);

					var licensedRuntimeInfos = GetLicensedRuntimeInfos(matchingRuntimeInfos);
					if (!licensedRuntimeInfos.Any())
						throw NoRuntimeLicenseException(targetRuntimeVersion);

                    runtimeInfo = GetBestMatchRuntimeInfo(licensedRuntimeInfos);
                }
                return runtimeInfo;
            }

			private static IEnumerable<TestShellRuntimeInfo> GetMatchingRuntimeInfos(IEnumerable<TestShellRuntimeInfo> runtimeInfos, string targetRuntimeVersion)
            {
				return runtimeInfos.
                    Where(r => IsGreaterOrEqualVersion(r.Version, targetRuntimeVersion)).	//only matching versions
					ToList();
			}
			
			private static IEnumerable<TestShellRuntimeInfo> GetLicensedRuntimeInfos(IEnumerable<TestShellRuntimeInfo> runtimeInfos)
			{
				return runtimeInfos.
					Where(IsLicenseValid).													//only licensed runtimes
					ToList();
			}

            private static TestShellRuntimeInfo GetBestMatchRuntimeInfo(IEnumerable<TestShellRuntimeInfo> runtimeInfos)
            {
                TestShellRuntimeInfo bestMatchRuntimeInfo = runtimeInfos.                    
                    OrderBy(r=>VersionStringToComparableNumber(r.Version)).FirstOrDefault();//best match
                return bestMatchRuntimeInfo;
            }

			private static bool IsLicenseValid(TestShellRuntimeInfo testShellRuntimeInfo)
			{
				string runtimeAssemblyPath = Path.Combine(testShellRuntimeInfo.Path, testShellRuntimeInfo.RuntimeAssemblyName);
				AppDomainSetup appDomainSetup = new AppDomainSetup();
				appDomainSetup.ApplicationBase = testShellRuntimeInfo.Path;
				AppDomain appDomain = AppDomain.CreateDomain("LicenseValidationDomain", AppDomain.CurrentDomain.Evidence, appDomainSetup);
				UnloadableLicenseValidator unloadableLicenseValidator = (UnloadableLicenseValidator)appDomain.CreateInstanceFromAndUnwrap(
                Assembly.GetExecutingAssembly().CodeBase, "QualiSystems.Driver.LearningLabsLabs_EnvDriver+TestShellRuntimeLocator+UnloadableLicenseValidator");
				bool isRuntimeLicenseValid = unloadableLicenseValidator.IsLicenseValid(runtimeAssemblyPath, testShellRuntimeInfo.RuntimeLicenseValidatorTypeName);
				AppDomain.Unload(appDomain);
				Trace.WriteLine("Quali Runtime: Runtime at " +testShellRuntimeInfo.Path+ " is " + (isRuntimeLicenseValid ? "Licensed" : "Unlicenced"));
				return isRuntimeLicenseValid;
			}

            private static bool IsGreaterOrEqualVersion(string comparedVersion, string baseVersion)
            {
                int comparedVersionWeighted = VersionStringToComparableNumber(comparedVersion);
                int baseVersionWeighted = VersionStringToComparableNumber(baseVersion);
                return comparedVersionWeighted >= baseVersionWeighted;
            }

            private static int VersionStringToComparableNumber(string version)
            {
                string[] versionParts = version.Split('.');
                int major = int.Parse(versionParts[0]);
                int minor = int.Parse(versionParts[1]);
                return (major << 16) + minor;
            }

            private static TestShellRuntimeInfo GetCurrentlyLoadedRuntimeInfo(IEnumerable<TestShellRuntimeInfo> readTestShellRuntimeInfo)
            {
                TestShellRuntimeInfo matchingRuntime = null;
                foreach (var loadedAssembly in AppDomain.CurrentDomain.GetAssemblies())
                {
                    try
                    {
                        matchingRuntime = readTestShellRuntimeInfo.FirstOrDefault(r => string.Equals(loadedAssembly.Location, Path.Combine(r.Path, r.RuntimeAssemblyName), StringComparison.InvariantCultureIgnoreCase));
                        if (matchingRuntime != null)
						{
							Trace.WriteLine("Quali Runtime: "+ string.Format("Runtime version {0} already loaded.", matchingRuntime.Version));
                            break;
						}
                    }
                    catch (NotSupportedException)
                    {}
                }
                return matchingRuntime;
            }

            private static IEnumerable<TestShellRuntimeInfo> ReadInstalledTestShellRuntimeInfos(string targetRuntimeVersion)
            {
                RegistryKey testShellRuntimeRepositoryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey(RuntimeRepositoryPath);
                if (testShellRuntimeRepositoryKey == null || testShellRuntimeRepositoryKey.SubKeyCount == 0)
                    throw NoMatchingRuntimeException(targetRuntimeVersion);

                List<TestShellRuntimeInfo> testShellRuntimeInfos = new List<TestShellRuntimeInfo>();
                foreach (var subKeyName in testShellRuntimeRepositoryKey.GetSubKeyNames())
                {
                    var runtimeKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey(Path.Combine(RuntimeRepositoryPath,subKeyName));
                    TestShellRuntimeInfo testShellRuntimeInfo = new TestShellRuntimeInfo();
                    testShellRuntimeInfo.Path = (string) runtimeKey.GetValue("Path");
                    testShellRuntimeInfo.Version = (string)runtimeKey.GetValue("RuntimeVersion") ?? (string)runtimeKey.GetValue("Version");
                    testShellRuntimeInfo.RuntimeAssemblyName = (string)runtimeKey.GetValue("RuntimeAssembly");
                    testShellRuntimeInfo.RuntimeTypeName = (string)runtimeKey.GetValue("RuntimeType");
                    testShellRuntimeInfo.RuntimeLicenseValidatorTypeName = (string)runtimeKey.GetValue("RuntimeLicenseValidatorType");
                    testShellRuntimeInfos.Add(testShellRuntimeInfo);
                }
                return testShellRuntimeInfos;
            }

            private static Exception IncompatibleRuntimeLoaded(string targetRuntimeVersion, string loadedRuntimeVersion)
            {
                return new ApplicationException(string.Format("Quali runtime version {0} needed but version {1} already loaded.", targetRuntimeVersion, loadedRuntimeVersion));
            }

            private static Exception RuntimeAssemblyNotFound(string runtimeAssemblyPath)
            {
                return new ApplicationException("Runtime assembly "+runtimeAssemblyPath+" is missing.");
            }

			public static Exception NoMatchingRuntimeException(string targetRuntimeVersion)
			{
				return TestShellRuntimeException("Could not find a matching TestShell Runtime with version " + targetRuntimeVersion,
												 targetRuntimeVersion,
												 "MatchingRuntimeNotFound");
			}

			private static Exception NoRuntimeLicenseException(string targetRuntimeVersion)
			{
				return TestShellRuntimeException("Could not find a license for TestShell Runtime version " + targetRuntimeVersion,
												 targetRuntimeVersion,
												 "RuntimeLicenseNotFound");
			}

			private static Exception TestShellRuntimeException(string description, string targetRuntimeVersion, string reason)
			{
				KeyValuePair<string, string>[] parameters = new[]
				{
					new KeyValuePair<string, string>("Target Version", targetRuntimeVersion),
					new KeyValuePair<string, string>("Reason", reason)
				};
				return new ErrorException("Quali Runtime", description, string.Empty, parameters);
			}

            private class TestShellRuntimeInfo
            {
                public string Path { get; set; }
                public string Version { get; set; }
                public string RuntimeAssemblyName { get; set; }
                public string RuntimeTypeName { get; set; }
                public string RuntimeLicenseValidatorTypeName { get; set; }
            }

			internal class UnloadableLicenseValidator : MarshalByRefObject
			{
				public bool IsLicenseValid(string runtimeAssemblyPath, string runtimeLicenseValidatorTypeName)
				{
					Assembly runtimeAssembly = Assembly.LoadFrom(runtimeAssemblyPath);
					Type runtimeLicenseValidatorType = runtimeAssembly.GetType(runtimeLicenseValidatorTypeName);
					bool isRuntimeLicenseValid = (bool)runtimeLicenseValidatorType.GetMethod("IsRuntimeLicenseValid").Invoke(null, null);
					return isRuntimeLicenseValid;
				}
			}
        }

        #endregion TestShellRuntimeLocator

		interface IFunctionInterpreter
		{
			Dictionary<string, object> Run(Guid callId, Dictionary<string, object> inputNamesValues, Dictionary<string, Type> outputNamesTypes);
		}
    }

	
}